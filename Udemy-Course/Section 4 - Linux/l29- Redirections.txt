OK, next, we're going to see input output redirection so we know standard output device to our computer

is the monitor the screen so we run anything on our computer, any program.

The output mostly will be coming on the screen.

Right.

Like we run the uptime command. Output is on the screen, see, possibly it's coming on the screen, so if

there is an output needs to be printed, the standard output devices or screen.

Yes, that's also common sense.

But my point is you can change that standard output device for a command that you're running.

Let's say you're running uptime.

Come on.

And you don't want to print it on the screen.

Maybe you want to redirect it to another fine.

So use the redirection symbol and let's create a file.

It's in /tmp directory. I will say /tmp/sysinfo.txt.

So you see the output did not come on the screen.

It went to this file.

Right? like that, I'm running ls Command showing on the screen, I can redirect it to the same

file, but what happens when I do redirection is.

If the file does not exist, it will create the file, if the file already exist, it will.

Overwrite its content

All right.

So previously we had this content and now if you see the content would be overwritten.

Right now, if you have the file names from the ls command, but if you don't want to overwrite.

You just want to upend the content and you can use double arrows, output redirection appended.

OK, now we will see /tmp/sysinfo.txt

.

Now, the other content.

OK, I'll show you now three simple commands in the next one, you have already seen uptime that shows

the up time. free -m that is going to show you the memory utilization. Memory means the RAM, the

physical RAM. Swap is the virtual memory.

So physical RAM, is says total 486 mb, 100 is used, 35 is free, 369 is available.

OK, so.

I will redirect that information to the file.

One more df -h, this is going to show you the hard disk partition utilization.

So that is your root partition and it is size 50GB, it says.

1.5 gb is used, 49GB

GB is available.

It's mounted at root dir /

Will learn this command later in detail and just.

I want to show you some command, so we can use its output.

And I'll also show you one more command echo, echo is a print command, so what do you want to print

like?

Good morning.

It's just going to print it.

That's OK.

So now I'm going to use this echo, command, and print some hash and not really print, I'm going

to send it to the file, /tmp/sysinfo.txt. So I use single redirection, everything will be replaced.

There's also one more commands output I would like to redirect, date, let's do it once again will redirect

the output of /tmp/sysinfo.txt

And let's do this one once again, but now.

Double arrow.

So you have date in the file, then this hash, and then I'll put the uptime command output. uptime >>

/tmp/sysinfo.txt

And let's put this hash once again.

Then the output of free -m

Again, hash, then output of df -h

I mean, again, hash.

OK, now let's see the content of the file.

That looks fancy at this particular time.

This was the up time, this was the RAM utilization.

This was the disk utilization.

Now, this will be very handy when we are writing Bash scripts.

So that's about output reduction.

to a file, but if you don't want to see output. Not on the screen, not in any file, then you can readirect

the output to somewhere else, which is /dev/null

Now, this is a file that does not contain anything.

And if you throw anything in this, then it's gone.

It's like a black hole in galaxy.

So let me show you this.

I ran the command yum install vim -y which is going to generate a lot of output.

But I don't want to see the output.

I just say output reduction and dev null.

So you see output is gone.

OK, we're not seeing it now, if you want, you do dev null thinking that the content will be there,

but there's nothing in that, just like a black hole.

One more use of /dev/null file, I'll show you.

So let's say I want to clear this file content.

I don't want anything in that.

Yes, you can open, do delete all the content, but there is an easy way you can do cat /dev/null and redirect

the output to file.

And that file will have then nothing.

That sounds a little philosophical, right?

It's very handy. Now if you check the file content, everything will be wiped out clean.

So what came out of /dev/null file was nothing, and we redirected nothing to a file and then the file

became nothing.

OK, these tricks will be very handy in bash scripting.

OK, so that's redirecting standard output, but you get errors sometime.

Like, I'm running command free -m, I redirect the output to /dev/null or any such output?

I didn't see anything, but if you make any errors, So I will or give a wrong command, it's too eeeee in free

freeeeeeeee

So you see now the error comes.

command not found

Not found.

If you don't want to see the error, you can do 2

Output redirection 2 means standard error, and if you would like to redirect it to a proper file like

/tmp/error.log

OK, then you do cat /tmp/error.log. Now you will see error there. So 2 is for standard error.

1 is for standard output, which is by default.

If you don't give one, even though it is the default value one, which is standard output, one, standard

output to standard error, but if you would like to redirect any kind of output, so you can just say

&, so if it's an output or even if it's it, it's an error.

Anything goes to that file.

So you see output came and then also error came to this file.

So programs or processes that are running behind the scenes will be directing output to a file, those files,

we call as log file.

So whatever log file you see in /var/log

.

These log files are getting generated or their content is getting created from processes that are running

behind the scene and they generate output, so they redirect either error to a specific file output

to another file, or sometimes both to one single file.

Like &.

Now, I'm saying this is handy in bash script because we write bash script, we run them in the background or any

kind of script, and we want to redirect that output to some file so we can review that later.

Right.

Such files are called as log files.

OK, so let me clear the screen now. So that was that was about output reduction, now we're going to

talk about pipe, piping.

So before that, I'll show you one, command, wc -l, this command is going to count line number

and you can give any path for file.

/etc/passwd, it counts.

How many lines are there

25 lines.

So here the input to this command is coming from the file.

But what if you want to count something else, like, for example, you go into /etc dir

Run ls command and you want to count number of files over here

So what you can do here is.

You can run the ls command and then pipe it

That's the symbol of pipe, | , pipe it with a wc -l.

Now, what will happen is, ls is going to generate the output that output goes as an input to the

right hand side commands.

That input will be coming like this.

And so, as it is going to count 186 files total, that's a nice trick.

OK, other things, aa... you want to see.

Search for a file name, let's say, host, that starts with host & ends with anything. Now grep

will get input from this command.

And it's going to search and there's nothing.

Oh, yeah, I don't need to give this star, otherwise it is thinking that it's a file named host*

OK, so ls grep host and there you go, all the file that starts with the name host.

Or maybe you are doing head to a file, lets say /var/log or tail, lets do tail /var/log/messages

And you want to see if there is some event with named Vagrant, there is nothing, tail -20.

Yeah.

So from last 20 lines of this file, we are searching for texta named vagrant and there we go.

So like that, the numerous benefits of this piping, like free, -m, I just want to see the

ram, I don't want to see Swap, I dont want to see the third line and I don't want to see the heading.

I just want to see this line.

So I will find something unique over here which does not change like Mem.

So I'm going to say free -m | grep Mem

You can really pipe any command as long as it makes sense, like ls -l and you want to pipe it

with.

tail command

So last 10 files.

Or 1st 10 files.

And then it's all about your imagination.

We're going to do a lot of piping and filtering in scripting, so this will come very useful.

I'll get one more last command on in filter, which is find.

So far, we are looking at the content of the file.

Now, if you want to find the file itself, then you can use find come on, you can say find me a file

in, let's say /etc/ -name and the name of the file, let's say is host or it starts with host the

find and we give the path and we say find it with the name of the file.

And there we go now you can make a search at the root level also, which is searching the entire operating

system, but this may slow down your operating system also.

Now, we don't have many things over here, not any huge data.

So it worked.

But I do not recommend making search the root dir because this this is a real time search.

One easy way of searching is also through locate.

command

But look, it will not be installed by default.

So you have to install this software, mlocate.

mlocate, we have installed mlocate now you have to run a command called updatedb.

Now, locate, is not a realtime search, so it's going to search from its database, which gets updated

with this command to locate and I say host.

So it's going to search from its database every file that has the name host in it.

And there are quite many files.

Now, it's not a realtime search, so even if you happen to delete some file, it will still be showing

it if as long as you don't run updatedb command.

So before you run the locate command, you make sure you're an update DB so you get right info

or are the existing data

Well, that's all in the filtering here in Pipeing, redirection, run the history, command and see

what are the commands or order of the commands that you executed and practice them more. You should be really

very good in this filtering and redirection before you step in.

Bash scripting.

All right, then, wrap this up and join me in the next video.