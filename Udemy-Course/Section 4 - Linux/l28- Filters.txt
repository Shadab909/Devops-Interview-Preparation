Filters and a redirections in this video, we will be talking about how to get data by filtering out,

should I say, get the right data for me, and then also redirecting that data to a file or a program to

process more further.

If you really want to be smart in Linux, you should be very good in filtering and redirection.

This is also very helpful in scripting.

So we're going to see some filtering.

command

And then we're also going to talk about input output, redirections like filtering, grep command

grep command to find some text from the files.

Less command, more command, which are a reader of the files.

Head or tail command to see the first in line or last 10 lines.

Getting a particular column from a file by using Cut Command.

Search and replace file content by using sed or even vim editor.

We'll see then redirecting output to a file, redirecting standard output and redirecting error, also

appending the content.

Or redirecting all kinds of output to file. We will see piping will see pipe and we'll see how we can use

the output of a command as an input to other command or passing instruction to the next command, which

will do some operation for us.

We also see how to find the file with its name and some other parameters and a few more tips and tricks

of system administrators.

So let's learn them one by one, so I'm in linux vm I'm going to do sudo -i to become

root user.

Here we have a file anaconda-ks.cfg, we have seen this file previously.

We are going to do some operations on this file.

If you wish to use any other file, that is also fine.

So I have a file anaconda-ks.cfg and I am looking for a text in that file, whether it exists or not,

so I have a command called grep and I'm going to say grep firewall, basically look for a text called

firewall in the file. So, command what you want to search and the file path, hit enter

and it should show me the line which contains the word firewall.

Now, Linux is case sensitive, so you have also there capital Firewall, capital. Both are different.

if you want to ignore the case sensitivity, you can use -i

So it will show you all the content or all the lines that contains the word firewall, even if it's

small or capital. Let's edit this file and let's put somewhere some content. We will say fire and w

say W capital firewall is off in this machine.

Just some text.

And I want to save and quit this.

Now, if I do grep -i firewall, small capital, whatever, it's going to show me all the lines

that contains the word firewall.

So here f is capital, here f is small, here w is capital.

So all of that not.

I'm just giving input over here.

of this file, when you talk about input.

Your command will have an input redirection symbol like this, which is invisible.

So basically what's happening is this file is coming as an input for this command.

You see the same result, so that's by default, you don't need to mention it, that's input redirection.

that's just about one file.

But what if I'm looking for multiple files.

Yeah, I'm looking for content in the current working directory, all right, so I can see grep firewall,

I'll use -i here and I will mention, I can mention, I can do star, which will mean all the

files in the current dir.

So let's do that.

So it shows the file name, so you have three lines from anaconda-ks.cfg, from orignal-ks.cfg

also you have one line which matches.

But for a dir, its throwing an error, devopsdir: Is a directory

So it is not going to get into the directory if you wanted to get into the directory.

Then use the option R, -R, not using I just use -R, but we are using -i also, -iR

it will get into the dir also.

Since, there is no such thing, you know what, we will put this file into devopsdir with a different name

mybootingfile.cfg

OK, I copy the file, same file over there.

Let's do it once again.

Now, you see, it also gets inside the directory and show you and search for the file.

With the content that you have mentioned.

Now, that's interesting.

Now think about it, if you're looking for a configuration that you want to change, but you really

don't know in which file it is located, you at least know it's an /etc dir, but you don't know

which file it is.

Like, for example, you're searching for a setting called selinux, CAPS.

OK, try this exercise.

SELINUX is security enhanced Linux and sometimes we need to switch it to permissive or disabled

mode from enforcing mode.

So we know there is this setting called SELINUX ,CAPS, but we really don't know in which file it is located.

So I'm going to say grep SELINUX and I'll say /etc

And I I don't know whether it's in subdirectories or not, so I'm going to give an option -R

/etc/* , so look for all the files, subdirectories, all the files, basically for a text

called SELINUX

And then you can go through the result.

Now you do not need to get into what is selinux for now

But I'm just showing look, you're looking for a setting but you don't know in which

file it is. You can do a search like this.

Right.

And when you got your result.

No, that's that's the file.

So you can use that file.

Open that file and you see it says selinux is in permissive mode.

I want to change it to maybe disabled mode, so make the change disabled.

And save and quit.

And for selinux to take effect, you need to reboot machine, but we're going to skip that part for now

and you have to understand how powerful this method is.

You want to change configuration, configuration are stored in text files, and most of your operations

will be like this.

You look for a file, you make the change either manually or automatically through your scripts.

So this is a very effective trick of system administrators.

So they don't need to memorize things.

OK, one more option with grep.

grep has one opposite searching option -v, it is like you know, do not search for anything that

says firewall or I will also put i for case sensitivity.

So it's the opposite, do not show me any content, any line that contains firewall, except that it's

going to show you everything.

OK, and that's a very long file, so you can check that you not see anything that contains firewall

except that all the lines are displayed reverse search.

-v option

OK, let's see other commands now, less, less is a reader.

So you say less and you give a file path that you want to read.

You know, you can use cat also, but cat just displays all the content and, you know, just quits.

less is a reader.

So you can use up arrow down arrow, you can read the content.

It looks like vim, but it's not an editor, its reader.

And you can also make search also from here.

Forward slash.

Let's say you're searching for a network.

Yeah, like that, if you want to quit just use q to quit

Similar to less there is one more. more and the file path.

Now, more you cannot use up arrow, down arrow, you have to use your enter return keys and it's going

to show you file in the percentage way.

I really don't use it much.

I use less, more than more.

But then again, it's your choice.

If you want to quit, you can just go till the end or you can use q to quit.

Yeah, so more and less, it's your choice.

Sometimes you just want to see the first few lines of a file so you can use head command and you can

give the file path, it will show you first 10 lines of the fine.

But if you want, you can change.

You want to see 1st 20 lines.

You can say -20

1st 20 lines or you just want to see 1st 2 lines, head -2

OK, that's handy, you don't need to read the entire file, the opposite of it is. tail.

tail is going to show you, as you would have already guessed, last 10 lines of a file.

And again, you can use your numbers, you know, you can see first two lines or how many lines you

want to read.

Now, tail has also one very useful operational, option, -f, hyphen f, and you give a filepath

.

It will show you the dynamic content.

So it's not quitting.

If you see, I hit enter, you see my cursor is just blinking there.

So if any changes happen in this file, it's going to show me on my screen, which is good when we read

log files.

So, do control c, control c, to quit from here.

Now, talking about log files, let me show you.

One example.

So log files of the systems are located in /var/log

Here you will see log file of the system or if any service that is running any server, you'll see logs

in this directory by default.

But some servers have log files in some other directories also.

Like, yum, yum.

So let's say, tail -f yum.log

.

OK, so you see the last 10 lines and if something is happening, you can see the logs updating over here

.

The system log file is message

messages, in Red Hat machine, messages is the system's log file.

Which will record a lot of information, you can do a cat to this file, you see a lot of information,

so its a new system, so you really don't see much information, but it will show login events also.

So let's do this.

Just open one more gitBash

And will make a logging attempt.

And before we do that, I will just do tail -f /var/log/messages

ok, hit enter.

OK, so there it is.

Tailing the log and now from another git bash, I will get into that directly.

And I will make a logging attempt by ssh, which which will be a successful attempt.

And this logging event should be recorded in this file, and you should see dynamically this file getting

updated on my screen.

See, there, here, I made a log in and you see the event over there, right?

So that's how the tail -f option is very helpful.

When you're troubleshooting one very important tip about troubleshooting a server, you see errors in

log files.

That's how you start troubleshooting.

So every server will have its own.

Every service will have its own log file.

And you see some error.

You want to see when does this error triggers, when does this happen?

So you can probably make some changes or restart the service.

And by the time you know you're doing those changes, you can keep tailing in one shell, in one session

and you will see if you do this particular thing, you see the error and that's how you can start troubleshooting.

Then more further you can funnel down to the problem.

OK, let's do a control c

So one more system administrators, trick or type.

OK, now let me show you a file /etc/passwd, this file contains user information, all the users

in our systems and there information. We will get into users and group in the next video.

Now, we are just doing some filtering over here, so I want to get all the user names.

This file has all the user name, but it has all the other content.

Although I don't want all that content, I just want the user names or maybe just the user.

Whatever we want, we can get from this file because this file is properly segregated into rows and

columns.

These are the rows and the columns are separated by colon.

OK, so you have username colon and some information colon and some information, and we'll understand

what the other information.

But first one first column is username.

So this file is properly segregated by using Colon's.

And if you have that proper separators or proper delimiters like colon or comma or anything, then you

You can use cut command.

cut, you see -d delimiter or the separator :

And you say -f1, field, one, column one, and you give the file path.

So it will show you just the field one, the first column of the entire file.

That's nice and all, but for cut command, the delimiters are very important.

You can use, lets say filed three, which shows you the userid field 4, group id, like

that.

You can see whatever field you want, but this is good only if you have a proper separator like here,

colon

But if you don't have proper separators, then there's an intelligent filter tool.

called a awk

awk lots of options.

You can use all your regular expressions, all your filtering techniques and you can use awk command

to apply all those filtering techniques using regular expressions.

I'll show you one simple example as we've seen with Cut now.

cut -F':'

You give the delimiter and in single quote you create curly braces and say print $1

Now this may look more complicated than cut, but sometimes for some advanced search or intelligent

search, awk is always better.

We're going to see more example, on awk later.

One simple example as cut, getting the first column.

OK, we'll see, search and replace.

Now I have a sample file over here that has three sentences and it has the word coronavirus, coronavirus,

coronavirus, coronavirus.

I know it's everywhere, at least now when I'm recording it.

But there's also a vaccine now from Moderna and from Pfizer, even though it is still spreading and still

it's a pandemic and a huge, huge pandemic.

Anyway, let's search for the text coronavirus and replace it with covid-19.

So we have two ways.

One is through vim, just for single file.

So open the file.

:%s/

:%s/, which means search for corona virus and then forward slash and replace it with, let's

say, covid-19.

Right, I hit enter.

And you see, it has changed at three places there, there and there, but not here, if the same text you're

searching is multiple times in the line, then it will not make the automatic replacement it will find

is a text to replace it and go to the next line if you want to replace it.

Everywhere, I'm using u to undo first, yeah.

OK, so if you want to replace it everywhere, then do the same thing, search for coronavirus or replace

it with covid-19 forward slash /g, g means global.

So every place you have coronaviruses, replace it with covid-19.

And that's it.

I'll show you one more trick, Coolen %s, search for now, we'll search for we have covid-19

search for covid-19 and I want to replace it with nothing like, you know, I want to replace covid

Corona with nothing so forward slash g.

OK, 2 //, that means search for covid-19, replace it with nothing.

Now.

There is a spelling mistake, oh, there's a spelling mistake, typographical error.

covid-19 replace it with nothing. Hit enter and you see that, see that we really

dont need a vaccine, we just need a sed command to replace it with nothing.

I know that's bad joke but anyways.

So I'm not saving the content if you save, it is saved.

I'm just going to quit forcefully.

Now let's do the same thing with sed.

Now if you want to do it out of the vim, if you want to do for multiple files, you can.

use sed command. sed in single quote slash searching for coronavirus and replacing it with covid19.

Again, g for global, if you don't use g, then you know what happens.

And give the file path. Now here, you can use regular expressions also, you know, probably you have

multiple files that has. You can say, *.txt for all the text search.

Or you can just say * for all search, for all the files in the current dir. for coronavirus and replace

it with covid19.

That's very handy.

Trust me, we need to do a lot of changes and sometimes we need to change settings in multiple files

and which will have multiple, multiple, multiple lines.

So this will do it just like that.

You know, you don't need to, like, open all the files and do a search and replace, you know, it's

very easy with sed command

So that's one more tip or trick for you.

OK, but when you do it with sed command it will just print it on the screen, it will not actually

make the changes.

If you see the file, it will still have coronavirus.

Yeah.

That was just printing, if you want to change it, then you have to use an option -i

So it's like a little safer, right?

First you see what you are changing and then if you're good and use -i to actually change the

content.

Yeah, now it's changed, OK?

How do you want to make some other change, like now you have covid19 in this?

Fine.

And I want to replace it with nothing as nothing next.

Yeah, let's see the file.

You see that moderna has creat, I should say, created a vaccine for nothing, for nothing.

Pfizer has also created a vaccine, nothing spread through water droplets in the air and nothing is

a pandemic.

That's a big lie.

OK, that's just for fun.

Coronavirus is really very, very deadly and we should be really safe.

We're using our masks, sanitizing our hands and maintaining social distancing.

And that's the only way now unless we get a vaccine.