In this video, we will be seeing different types of files in Linux, we already seen two types of file.

One is the text file.

The other one is directory, yes.

Directories also file like keyboard is also file, mouse is

also a file. The ssh that you're doing, the tty session that you get, that is also file.

Everything is file in Linux, but there are different types of file.

So let's see now different types of file in Linux.

So I will get to my VM, /f/vagrant_vms/centos

It's an F drive, vagrant-vms/centos7, it's already up, so I'm just going to say, vagrant ssh.

OK, for this one, let's switch to root user.

Now, ls with an option, -l, hyphen l is called a long listing, it's going to show more

information about the file.

Let's create a directory also over here.

Let's do ls -l again

So so far, by color, you must have been understanding that this is a file and this is a directory,

but really the colors comes from the client.

So this gitbash we're using, this gitbash is showing us these colors.

But, there is information available over here, if you see here.

At the beginning, if you see a - in the information, that means it's a regular file, regular

file could mean it's a text file or it could mean it's a binary file also.

So to be sure, you can run the file command you can give the path of the file.

I'll give this, so it says ASCII text.

So it's a text file.

We have already seen that.

But there's also, then if you go to bin dir.

ls -l here.

You see a lot of file over here and there is a hyphen over here, that means it's a file, but there's

no guarantee if its text file. So we can run the file command.

File and let's say yum.

Well, yum is also a text file, but it's a Python script. Or lets do file to some other file.

Let's give absolute path this time. /bin/pwd

OK, that's a binary file, so there was a program written, then it was compiled and you got the binary

file from that. ELF 64 bit LSP executable.

You see the version. Sorry, architecture, that's 64 bit dynamically linked uses shared libraries.

It's a binary file.

OK, let's go back to your home dir.

lets clear the screen.

ls -l, so hyphen is for a file and the d for directory, so you can run a file command on this directory.

This is directory.

Now, these are the files will be usually manipulating, directories, files, but then there is a slash

/dev dire

This dir contains device files. If you do ls -l.

You should see the different characters.

C is for characters like Keyboard is a character device.

So you'll see for keyboard, c.

tty, that's the session, the commands where we are running that shell.

shell, we get a tty session.

That's a character file.

sda, that is our hard disk, yes, that is our hard disk, and you see there's b. b means block file

block file.

So any kind of block disk, if you attach, it will be read as block disk.

Block file.

l is for link. Like shortcuts we have, like we have desktop shortcuts, that's not the original

file.

It points to some other file, right.

So this is a shortcut.

So a link file.

It points to this file.

This is the original file.

OK, and this rtc0 is in the same dir here, and that is a character file.

So block.

Character socket.

s is for socket, these files, we don't do really any operations on that mostly, but it's good to know

what kind of file you're dealing with so you can use appropriate commands.

So, - regular file. d dir. l link file. c character file. Mechanism used for input output,

such as files in dev. s socket file. Used for inter process networking and p, pipe file

Now we have seen regular file text files.

We have seen we did operations on them. We did directory operation.

Now let's do some link operation.

We will create links.

So I'm in the root users home dir and I'm going to create a link here to a file that is somewhere

else located, so I'm going to create a directory in /opt inside that I will create a dir dev

inside that, I will create dir named ops

And inside that devops, inside that.

Directory named test. Now if I run this, command, there's no dev dir, so it will not be able to create

ops and other directories.

So it's going to throw me an error.

But if I use an option -p, then it will just create that entire dir structure for me.

No questions asked if I run this command once again.

Also, there's no error.

Right.

But if I use if I don't use -p and the directory already exist, it's going to throw me an error

that dir file exist. Now, I'll create a file inside that, dir, opt, dev, ops, devops, test.

File named commands.txt

OK, I just write some commands over here.

Put any content you want and save it.

Now, let's say there is a file that I regularly access, which is so many levels in, and usually I

log into my home dir and from there I want to access the files. So I have to give this complete path

complete path, which is very long.

So instead of that, I create a link over here.

So I'll give the command ln -s, which stands for Soft Link.

Just like shortcuts, firts, you give the destination.

Yes.

First to you the destination file and then you do the source file.

So destination I'm giving absolute path, source also.

I can give absolute but I'll give you a relative path.

I will say cmds

If I do ls -l

I should see a link, cmd, that points to this original file, so if I do cat cmds , I should see the

content from that file.

All right.

You see this link file, right?

OK, what happens if the original file is gone?

Let's move that original file to somewhere else.

Let's move it to /tmp.

ls -l

And you see, it will be blinking.

It will be highlighted like that.

This means it's a dead link.

It points to a file that does not exist.

.

Well, I'll move back that file again to the same path.

And I don't need to do anything else, the link will be back live again.

OK, watch out the path that I'm using, the absolute paths.

OK, let's clear the screen now.

If you want to remove a link, you can just remove the file directly by using rm Command or you can

use unlink command also.

And that should be gone now.

But it's just the link that we have removed.

OK?

Original files still exist, so I'm creating the link once again, ls -l. Now few more options.

With ls Command. -l shows you lot of information about the file, but it is going

to sort as per the alphabet's abcde like that.

If you want to sort it as per the timestamp, you can use t.

There is a timestamp on every file when the file was last updated.

OK, so if I do ls -lt, it's going to sort as per the time stamp, it will show the latest first

and the older one at the end.

If you want to reverse the sort you can use, r.

It is going to show you the latest file at the end and which is very good if you have a lot of files,

for example, if you go to /etc directly or I will not just go, I'll just do it from here.

ls -ltr /etc

ls -ltr /etc

It is going to show all the files in this directory.

And sort it as per the time stamp and then reverse it.

And we'll do one thing, we're going to change the host name now, host name. /etc/hostname file

I will change the hostname to

centos.devops.in

save & quit.

Now, when you change that, you can run one more command hostname and the hostname centos.devops.in

.

OK, then we logout you can use ctrl+d or exit.

And then we login back in again.

And now you should see the host name has changed.

Let me clear the screen.

And again, run the hostname command and cd hostname, and you should see ls -ltr /etc/

That's the last file that was updated.

So you are also seeing how we change configuration.

We just edit the file.

Make the changes, save it, and that's it.

So it's a normal ASCII text file and we can make the changes by using vim editor. Again to get all your

previously executed command, run the history command and get all your commands.

Now currently its showing history of vagrant user.

If I do sudo -i , I ran history command.

And this is the history of root user. Well, that is all in this video.

I will see you in the next one.