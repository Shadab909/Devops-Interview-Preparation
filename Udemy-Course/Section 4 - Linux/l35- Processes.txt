Hello and welcome in this video, we will be talking about processes so there are so many processes

you will see running in the linux system, running or sleeping.

There is one command top which will show you all the dynamic processes based on their consumption

of CPU and RAM.

So this is similar to like a task manager.

You have it on windows and it's a very helpful command it shows lot of information.

It is going to show up time.

So system up from past nine minutes.

This one user logged in and then you have load average.

Load Average is CPU wait time it is different and CPU utilization.

If the CPU utilization is full, then the load average will start increasing.

And you see three values over here.

Comma, separated.

So this is the current minute load average, this is last five minutes load average and this is last

15 minutes load average.

So your processes are called tasks.

So there are 117 tasks total out of them.

Only one is running and 116 are sleeping.

Looks like a very lazy operating system, but that's how it works.

Zero are in a stopped state, there is a stopped state also for a process which you can start by issuing

some commands, zero zombie processes.

Zombies are the processes whose operations are done.

But there entry is still in the process table.

We will see that later.

CPU utilization is 0.0 currently.

And then you see the RAM and swap detail, which is better to see through free -m

free -m command

Then you have the process id and you see these processes are really dancing.

They're just getting sorted automatically based on their CPU consumption.

The first column you see PID, process id.

Every process will have an ID, we generally call them as PID. User which is running that process.

So there is the process name like Top, Systemd, kthreadd , these are the process names and these are

the users that are running that process.

The root user is running this particular process and now this jenkins' running Java. See that's dancing.

But we will see other commands where we can really see all the processes.

So you can see the status of the process. s stands for sleeping and the

CPU It's consuming, RAM it's consuming and the process name.

OK, I'm going to give q, this is to quit from here.

q and I'll clear the screen

We'll see other command like ps aux

It is similar to top but it diplays information on the screen and it just quits.

OK, so it's going to show you all the processes, but you should see similar information as the top

command.

PID 1 is the first process which in new systems is systemd in older Linux systems, it's init.

but in Ubuntu it's still init.

That's the first process in the Linux, either init or system.

And this process is going to start so many other processes and will also handle so many other child processes

as well.

The process that you see in this square bracket, these are kernel threads, and you come down and you

should see some normal processes like httpd process, and you see multiple httpd processes because httpd

is running. When we said systemctl start httpd, which started these processes.

There is also sshd processes

So this this is going to sort with the process id and it's also going to display the utilization, it's

going to sort as per the PID

Then you have ps -ef, which is going to show you all the processes again.

But it's going to show you, not the utilization, but the parent process.

And that's the extra information minus the CPU and RAM utilization so PID 1

PPID, that is parent process ID, which was, you know, which process that started this process.

So there is a process ID which is zero that started this process.

But then you don't see a zero process because it's dead.

It's at the boot time.

So if you scroll down, you will see httpd process.

And I can say this process has started all these other processes.

How?

Well, check this out, PID is 1420

PID 1420 for this process and PPID is 1, then this process.

PID 1421

Its parent is 1420, which is this process. Again here

also 1420, 1420, 1420....

So that's the parent process id.

So I can say that this process has started all this other child processes.

Which is also called forking.

OK, so I have systemctl command, I can stop this process, but what if I don't have a systemctl

systemctl

command

Well, then how I'm going to stop a process?

Well, there is a command kill

You know what?

First, let's get this process id, ps -ef

grep httpd

So it shows all the httpd process and plus it also shows one more process, that's a grep process and

it's already dead.

That was the grep command.

.

And I don't want to see that grep process, so I'm gonna pipe it with grep -v and I'm going to

say do not show me a process that has the word grep in it.

Or you can say color also, whatever.

OK, so I only see the httpd process now.

Now, if I want to stop this process, I can say kill and give the parent process id, which 1420

1420

hit enter

And now you should not see those httpd process, so when I say kill, which sounds harsh, but it's actually more

of asking this process, hey, can you please close your operations?

So this process will first close all the child operations and then it will close itself.

So this is more of asking, but sometimes process becomes adamant and it does not listen and you have

to forcefully kill them.

System start httpd

So let me start this process.

Let's search once again.

OK, so forceful is -9, you don't have to issue -p every time because kill is better,

but if sometimes it does not work, you give -9, which is forceful and you give the parent process.

But this time it's not going to close the child processes.

This process will become orphan because.

The parent process has no idea that, you know, it's getting closed.

Now, you see these processes are adopted by the systemd, process, the first process and these

are orphan process, nowadays, the systems are smart.

This orphan process will get cleared automatically.

But if if it does not get cleared and you have to kill all these processes now, they're like, what?

Five child processes or orphan process.

But if your many, many, then it will be difficult to do that so we can use some filtering.

filtering command here

So let's say, it's still there. Let me clear the screen. Its still showing. So I am going to pipe that with awk

and I want to get the PID.

So I, I need just a second column.

So I'm going to say, awk, in single quote.

curly brances

print $2

OK, I get the PID and then I can pipe it with a command called xargs kill -9

All right, so all this PID will come as an argument to this command.

So it's really a shortcut to kill all the processes, systemctl start httpd

Lets start it once again.

You see the PID of a httpd process and then you can pipe it again with xargs kill -9

so if you're issuing 9, then you make sure you do like this.

filter it find the process IDs, and then send it to kill -9 command

.

OK, this is one more trick or tip.

So you have seen the orphan process, if the parent process is dead, then the child process will

be adopted mostly by PID1 and these process are called orphan process.

Orphan process will not serve much purpose, but it will still consume the resources.

So it's ideal to clear the orphan processes.

Right.

And to do it all at once will be better.

So that's orphan process, zombi process are easy to identify, they'll have status as z in ps aux command.

you can find out and you will also see how many zombi process are there.

As their name says, Zombie's, dead, like we see in the movies. Process, which is dead, but its

entry still in the process table.

It is not consuming resource, but it may create some problems.

The best way to clear zombie process is to reboot your machine, but there are some other ways to refresh

your process table also.

So I'm going to quit here.

So we have seen very simple commands top, ps aux, ps -ef, kill command

And we have also seen, how we can do filtering of your processes and issue a kill command on it.

So that is all in this video.

I will see you in the next one.